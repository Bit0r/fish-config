#!/usr/bin/python

# %%
from __future__ import annotations

import os

# 如果不需要使用代理，可以将下面注释
os.environ |= dict.fromkeys(
    'ALL_PROXY HTTP_PROXY HTTPS_PROXY'.split(), 'socks5://localhost:1080'
)
import re
from pathlib import Path
import mimetypes

from fire import Fire
from pint import UnitRegistry
import httpx
from dotenv import load_dotenv
from github import Auth, Github
from loguru import logger
import clevercsv
from pydumpling import catch_any_exception
from rich.progress import Progress
from more_itertools import first_true
from github.PaginatedList import PaginatedList
from github.GithubException import UnknownObjectException
from github.GitReleaseAsset import GitReleaseAsset

# %%
catch_any_exception()
load_dotenv(override=True)


# %%
class GithubDownload:
    def __init__(self, token: str | None = None):
        self.token = token
        # 最低优先级为19
        self.lowest_priority = 19

        # 确定基础发行版
        self.base_distro = self.__get_base_distro()

    @staticmethod
    def __get_base_distro():
        """
        获取基础发行版
        """
        if Path('/usr/bin/apt').exists():
            return 'debian'
        elif Path('/usr/bin/dnf').exists():
            return 'redhat'
        elif Path('/usr/bin/zypper').exists():
            return 'opensuse'
        else:
            return 'unknown'

    @staticmethod
    def __get_libc_type(name):
        """
        获取libc类型
        """
        return 'musl' if 'musl' in name else 'gnu'

    @staticmethod
    def __get_arch_type(name):
        """
        获取指令集类型
        """
        return 'amd64' if re.search(r'(amd|x(86[-_])?)64', name) else 'unknown'

    @staticmethod
    def __get_package_type(name):
        """
        获取包类型
        """
        suffix = Path(name).suffix
        if suffix == '.deb' or re.search(r'ubuntu|debian', name):
            return 'debian'
        elif suffix == '.rpm' or re.search(r'centos|redhat|rhel|opensuse', name):
            return 'redhat'
        elif re.fullmatch(r'.(xpi|vsix)', suffix):
            return 'extension'
        elif re.search(
            r'.(exe|msi|dmg|sha256|sig|asc)|darwin|macos|osx|\bmac\b|apple|win|bsd',
            name,
        ):
            return 'non-linux'
        elif suffix == '.run':
            return 'run'
        elif suffix == '.appimage':
            return 'appimage'
        else:
            return 'unknown'

    def get_asset_priority(self, asset):
        """
        0. amd64-gnu.<deb|rpm>,*.xpi,*.vsix
        1. amd64-musl.<deb|rpm>

        2. amd64-gnu.run
        3. amd64-musl.run

        4. amd64-gnu.AppImage
        5. amd64-musl.AppImage

        6. amd64-gnu.zip or amd64-gnu.tar.gz
        7. amd64-musl.zip or amd64-gnu.tar.gz

        8. amd64-gnu
        9. amd64-musl

        10. gnu.deb
        11. musl.deb

        12. gnu.run
        13. musl.run

        14. gnu.AppImage
        15. musl.AppImage

        16. gnu.zip or gnu.tar.gz
        17. musl.zip or gnu.tar.gz

        18. cli

        19. others
        """
        priority = 0

        name = asset.name.casefold()
        mimetype = mimetypes.guess_type(name)[0]

        # 确定包类型
        package_type = self.__get_package_type(name)

        # 确定libc类型
        libc_type = self.__get_libc_type(name)

        # 确定指令集类型
        arch_type = self.__get_arch_type(name)

        # 1. 如果是包类型未知，则优先级下降2
        # 2. 如果包管理和包类型类型匹配，或者为跨平台的软件插件，则优先级保持不变
        # 3. 如果包类型和包管理不匹配，或是非linux包，则直接返回最低优先级
        if package_type == 'unknown':
            priority += 2
        elif (
            package_type == self.base_distro
            or (self.base_distro == 'opensuse' and package_type == 'redhat')
            or package_type == 'extension'
        ):
            pass
        elif package_type != self.base_distro or package_type == 'non-linux':
            return self.lowest_priority

        if priority == 2 and package_type != 'run':
            # 也不是run包，那么优先级下调2
            priority += 2
        if priority == 4 and package_type != 'appimage':
            # 也不是AppImage包，那么优先级下调2
            priority += 2
        if priority == 6 and not (mimetype and mimetype.split('/')[0] == 'application'):
            # 如果没有mimetype，或者mimetype不是application，那么优先级下调2
            priority += 2

        if libc_type == 'musl':
            # 是musl包，那么优先级下调1
            priority += 1

        if arch_type != 'amd64':
            # 不是amd64包，那么优先级下调10
            priority += 10

        return priority

    def get_highest_priority_asset(self, assets: PaginatedList[GitReleaseAsset]):
        priority_assets = [None] * self.lowest_priority

        for asset in assets:
            priority = self.get_asset_priority(asset)
            if priority >= self.lowest_priority:
                # 优先级太低，那么就不用下载
                continue
            priority_assets[priority] = asset

        # 返回优先级最高的asset
        return first_true(priority_assets)

    def down_latest_asset(
        self,
        repo: str,
        version: str | None = None,
        *,
        progress: Progress | None = None,
        output_dir: str | Path = './',
    ):
        output_dir = Path(output_dir).expanduser().resolve()
        output_dir.mkdir(parents=True, exist_ok=True)

        gh = self.gh_client
        latest_release = gh.get_repo(repo).get_latest_release()
        assets = latest_release.get_assets()
        asset = self.get_highest_priority_asset(assets)

        if asset is None:
            logger.error(f'{repo}: no assets')
            return

        latest_version = latest_release.tag_name
        if version and latest_version == version:
            logger.info(f'{repo}: already up to date')
            return

        # 下载asset
        logger.info(f'{repo}: downloading {asset.name}')
        ureg = UnitRegistry()

        with (
            self.httpx_client.stream('GET', asset.browser_download_url) as response,
            open(output_dir / asset.name, 'wb') as f,
        ):
            if progress:
                task = progress.add_task(f'Downloading {asset.name}', total=asset.size)
                total_mb = (asset.size * ureg.byte).to(ureg.megabyte)

            for chunk in response.iter_bytes():
                f.write(chunk)

                if progress:
                    downloaded_mb = (response.num_bytes_downloaded * ureg.byte).to(
                        ureg.megabyte
                    )
                    progress.update(
                        task,
                        refresh=True,
                        completed=response.num_bytes_downloaded,
                        description=f'{asset.name}: {downloaded_mb.magnitude:.2f}/{total_mb.magnitude:.2f}MB',
                    )

            if progress:
                # 增加一个空行，防止进度条和日志混在一起
                print(file=progress.console.file)
                # 下载完成
                progress.remove_task(task)

        # 返回最新版本号
        return latest_version

    def download_list(
        self,
        releases: list[list[str]],
        *,
        progress: Progress | None = None,
        output_dir: str | Path = './',
    ):
        for idx, release in enumerate(releases):
            if len(release) > 3:
                # 注释行
                continue

            repo, version, description = release

            if not repo:
                # 没有repo，那么就跳过
                logger.warning(f'Line {idx + 1}: no repo')
                continue

            try:
                new_version = self.down_latest_asset(
                    repo, version, progress=progress, output_dir=output_dir
                )
            except UnknownObjectException as e:
                logger.error(f'{repo}: {e}')
                continue

            if new_version is not None:
                releases[idx][1] = new_version

    def download_all(
        self,
        lockfile: str | Path = './releases.csv',
        *,
        token=os.environ['GH_TOKEN'],
        output_dir: str | Path = './',
    ):
        output_dir = Path(output_dir).expanduser().resolve()
        lockfile_path = Path(lockfile).expanduser().resolve()
        if not lockfile_path.exists():
            logger.error(f'{lockfile_path} not found')
            return

        token = token or self.token
        if token is None:
            logger.error('No GITHUB_TOKEN found')
            return

        releases = clevercsv.read_table(lockfile_path)[1:]

        self.gh_client = Github(auth=Auth.Token(token))
        limits = httpx.Limits(max_connections=8, max_keepalive_connections=4)
        self.httpx_client = httpx.Client(
            headers={'Authorization': f'Bearer {token}'},
            follow_redirects=True,
            limits=limits,
            http2=True,
        )

        try:
            with Progress(auto_refresh=False) as progress:
                self.download_list(releases, progress=progress, output_dir=output_dir)
        finally:
            # 保存最新的版本号
            releases.insert(0, ['repository', 'version', 'description'])
            releases = [release for release in releases if len(release) <= 3]
            clevercsv.write_table(releases, output_dir / lockfile_path.name)


# %%
if __name__ == '__main__':
    # %%
    gd = GithubDownload()
    Fire(gd.download_all)
